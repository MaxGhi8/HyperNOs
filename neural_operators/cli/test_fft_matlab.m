% Test MATLAB 2D FFT implementation against PyTorch reference
% Load test data generated by test_fft_pytorch.py

clear; clc;

% Check if test data exists
if ~exist('fft_test_data.mat', 'file')
    error('Please run test_fft_pytorch.py first to generate test data');
end

data = load('fft_test_data.mat');
x = data.x;
weights1 = data.weights1_real + 1i * data.weights1_imag;
weights2 = data.weights2_real + 1i * data.weights2_imag;
modes = data.modes;
out_pytorch = data.out_pytorch;

[n_samples, in_channels, n_x, n_y] = size(x);
out_channels = size(weights1, 2);

fprintf('Testing MATLAB FFT implementation\n');
fprintf('Input shape: [%d, %d, %d, %d]\n', n_samples, in_channels, n_x, n_y);
fprintf('Modes: %d\n', modes);

% MATLAB Forward FFT
x_fft = fft(fft(x, [], 3), [], 4);
n_y_rfft = floor(n_y / 2) + 1;
x_fft = x_fft(:, :, :, 1:n_y_rfft);

fprintf('After rfft2 simulation: [%d, %d, %d, %d]\n', size(x_fft));

% Compare forward FFT with PyTorch
x_ft_pytorch = data.x_ft_real + 1i * data.x_ft_imag;
fft_diff = abs(x_fft - x_ft_pytorch);
fprintf('\nForward FFT comparison:\n');
fprintf('  Max difference: %.6e\n', max(fft_diff(:)));
fprintf('  Mean difference: %.6e\n', mean(fft_diff(:)));

if max(fft_diff(:)) > 1e-10
    fprintf('  WARNING: Forward FFT does not match!\n');
else
    fprintf('  Forward FFT matches PyTorch\n');
end

% Apply weights (using einsum equivalent)
out_fft = zeros(n_samples, out_channels, n_x, n_y_rfft);

% Top-left corner
x_fft_corner1 = x_fft(:, :, 1:modes, 1:modes);
x_perm1 = permute(x_fft_corner1, [1, 3, 4, 2]);
w1_perm = permute(weights1, [3, 4, 1, 2]);
x_flat1 = reshape(x_perm1, [n_samples * modes * modes, in_channels]);
w1_flat = reshape(w1_perm, [modes * modes, in_channels, out_channels]);

out_flat1 = zeros(n_samples * modes * modes, out_channels);
for idx = 1:(modes * modes)
    sample_start = (idx - 1) * n_samples + 1;
    sample_end = idx * n_samples;
    out_flat1(sample_start:sample_end, :) = x_flat1(sample_start:sample_end, :) * squeeze(w1_flat(idx, :, :));
end

out_corner1 = reshape(out_flat1, [n_samples, modes, modes, out_channels]);
out_fft(:, :, 1:modes, 1:modes) = permute(out_corner1, [1, 4, 2, 3]);

% Bottom-left corner
x_fft_corner2 = x_fft(:, :, (n_x - modes + 1):n_x, 1:modes);
x_perm2 = permute(x_fft_corner2, [1, 3, 4, 2]);
w2_perm = permute(weights2, [3, 4, 1, 2]);
x_flat2 = reshape(x_perm2, [n_samples * modes * modes, in_channels]);
w2_flat = reshape(w2_perm, [modes * modes, in_channels, out_channels]);

out_flat2 = zeros(n_samples * modes * modes, out_channels);
for idx = 1:(modes * modes)
    sample_start = (idx - 1) * n_samples + 1;
    sample_end = idx * n_samples;
    out_flat2(sample_start:sample_end, :) = x_flat2(sample_start:sample_end, :) * squeeze(w2_flat(idx, :, :));
end

out_corner2 = reshape(out_flat2, [n_samples, modes, modes, out_channels]);
out_fft(:, :, (n_x - modes + 1):n_x, 1:modes) = permute(out_corner2, [1, 4, 2, 3]);

% Compare weighted FFT with PyTorch
out_ft_pytorch = data.out_ft_real + 1i * data.out_ft_imag;
weighted_fft_diff = abs(out_fft - out_ft_pytorch);
fprintf('\nWeighted FFT comparison:\n');
fprintf('  Max difference: %.6e\n', max(weighted_fft_diff(:)));
fprintf('  Mean difference: %.6e\n', mean(weighted_fft_diff(:)));

if max(weighted_fft_diff(:)) > 1e-10
    fprintf('  WARNING: Weighted FFT does not match!\n');
else
    fprintf('  Weighted FFT matches PyTorch\n');
end

% Inverse FFT (NEW CORRECTED implementation with 2D Hermitian symmetry)
out_fft_full = zeros(n_samples, out_channels, n_x, n_y);
out_fft_full(:, :, :, 1:n_y_rfft) = out_fft;

if mod(n_y, 2) == 0
    for k_y = 2:(n_y_rfft - 1)
        % For k_x = 1 (DC in x-direction)
        out_fft_full(:, :, 1, n_y - k_y + 2) = conj(out_fft(:, :, 1, k_y));
        % For other k_x values (including negative x-frequencies)
        for k_x = 2:n_x
            % Negative x-frequency index
            k_x_neg = mod(-k_x + 1, n_x) + 1;
            out_fft_full(:, :, k_x, n_y - k_y + 2) = conj(out_fft(:, :, k_x_neg, k_y));
        end
    end
else
    for k_y = 2:n_y_rfft
        % For k_x = 1 (DC in x-direction)
        out_fft_full(:, :, 1, n_y - k_y + 2) = conj(out_fft(:, :, 1, k_y));
        % For other k_x values
        for k_x = 2:n_x
            k_x_neg = mod(-k_x + 1, n_x) + 1;
            out_fft_full(:, :, k_x, n_y - k_y + 2) = conj(out_fft(:, :, k_x_neg, k_y));
        end
    end
end

out_matlab = ifft(ifft(out_fft_full, [], 4), [], 3);
out_matlab = real(out_matlab);

% Compare final output with PyTorch
output_diff = abs(out_matlab - out_pytorch);
fprintf('\nFinal output comparison:\n');
fprintf('  Max difference: %.6e\n', max(output_diff(:)));
fprintf('  Mean difference: %.6e\n', mean(output_diff(:)));
fprintf('  MATLAB output: mean=%.6f, std=%.6f\n', mean(out_matlab(:)), std(out_matlab(:)));
fprintf('  PyTorch output: mean=%.6f, std=%.6f\n', mean(out_pytorch(:)), std(out_pytorch(:)));

if max(output_diff(:)) > 1e-5
    fprintf('  ERROR: Output does not match PyTorch!\n');
    fprintf('\n  Investigating further...\n');

    % Check if the issue is in IFFT
    fprintf('\n  Testing IFFT directly on PyTorch weighted FFT:\n');
    out_fft_full_test = zeros(n_samples, out_channels, n_x, n_y);
    out_fft_full_test(:, :, :, 1:n_y_rfft) = out_ft_pytorch;

    if mod(n_y, 2) == 0
        for k = 2:(n_y_rfft - 1)
            out_fft_full_test(:, :, :, n_y - k + 2) = conj(out_ft_pytorch(:, :, :, k));
        end
    else
        for k = 2:n_y_rfft
            out_fft_full_test(:, :, :, n_y - k + 2) = conj(out_ft_pytorch(:, :, :, k));
        end
    end

    out_matlab_test = ifft(ifft(out_fft_full_test, [], 4), [], 3);
    out_matlab_test = real(out_matlab_test);

    ifft_diff = abs(out_matlab_test - out_pytorch);
    fprintf('  IFFT on PyTorch FFT - Max difference: %.6e\n', max(ifft_diff(:)));

    if max(ifft_diff(:)) > 1e-5
        fprintf('  Problem is in IFFT/mirroring logic\n');
    else
        fprintf('  IFFT is correct, problem is in weight application\n');
    end

else
    fprintf('  Output matches PyTorch!\n');
end
